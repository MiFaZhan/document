
```
@Transactional  // 添加事务支持
@Rollback(true)  // 确保测试后回滚事务
```

```
package com.ruoyi.lvguan.controller;  
  
import com.ruoyi.common.core.domain.R;  
import com.ruoyi.lvguan.controller.vo.blockchain.BlockChainVO;  
import com.ruoyi.lvguan.service.IBlockChainService;  
import org.junit.jupiter.api.BeforeEach;  
import org.junit.jupiter.api.Test;  
import org.junit.jupiter.api.extension.ExtendWith;  
import org.mockito.InjectMocks;  
import org.mockito.Mock;  
import org.mockito.MockitoAnnotations;  
import org.mockito.junit.jupiter.MockitoExtension;  
  
import static org.junit.jupiter.api.Assertions.*;  
import static org.mockito.Mockito.*;  
  
@ExtendWith(MockitoExtension.class)  
class TbVehicleAccessoryControllerTest {  
  
    @Mock  
    private IBlockChainService blockChainService;  
  
    @InjectMocks  
    private TbVehicleAccessoryController controller;  
  
    @BeforeEach  
    void setUp() {  
        MockitoAnnotations.openMocks(this);  
    }  
  
    @Test  
    void getBlockChainDetails() {  
        // 准备测试数据  
        String txHash = "test_tx_hash_123456";  
        Long id = 1L;  
        BlockChainVO mockBlockChainVO = new BlockChainVO();  
        mockBlockChainVO.setTxHash(txHash);  
        mockBlockChainVO.setBlockHeight("1000");  
        mockBlockChainVO.setBlockHash("block_hash_abc123");  
        mockBlockChainVO.setBizId("biz_id_001");  
        mockBlockChainVO.setSigner("测试签名方");  
        mockBlockChainVO.setTxTime("2023-01-01 12:00:00");  
        mockBlockChainVO.setAccessoryType("钣金件");  
        mockBlockChainVO.setDescription("测试描述");  
        mockBlockChainVO.setSignature("test_signature");  
        mockBlockChainVO.setPublicKey("test_public_key");  
        mockBlockChainVO.setEncryptMode(1L);  
        mockBlockChainVO.setProofType(2L);  
        mockBlockChainVO.setFileName("test_file.txt");  
        mockBlockChainVO.setChannelId("channel_1");  
        mockBlockChainVO.setIpfsPath("ipfs_path");  
        mockBlockChainVO.setFromAddr("from_address");  
  
        // 配置Mock行为  
        when(blockChainService.getBlockChainDetails(txHash, id)).thenReturn(mockBlockChainVO);  
  
        // 执行测试  
        R<BlockChainVO> result = controller.getBlockChainDetails(txHash, id);  
  
        // 验证结果  
        assertNotNull(result);  
        assertEquals(200, result.getCode());  
        assertEquals("操作成功", result.getMsg());  
          
        BlockChainVO resultData = result.getData();  
        assertNotNull(resultData);  
        assertEquals(mockBlockChainVO.getTxHash(), resultData.getTxHash());  
        assertEquals(mockBlockChainVO.getBlockHeight(), resultData.getBlockHeight());  
        assertEquals(mockBlockChainVO.getBlockHash(), resultData.getBlockHash());  
        assertEquals(mockBlockChainVO.getBizId(), resultData.getBizId());  
        assertEquals(mockBlockChainVO.getSigner(), resultData.getSigner());  
        assertEquals(mockBlockChainVO.getTxTime(), resultData.getTxTime());  
        assertEquals(mockBlockChainVO.getAccessoryType(), resultData.getAccessoryType());  
        assertEquals(mockBlockChainVO.getDescription(), resultData.getDescription());  
        assertEquals(mockBlockChainVO.getSignature(), resultData.getSignature());  
        assertEquals(mockBlockChainVO.getPublicKey(), resultData.getPublicKey());  
        assertEquals(mockBlockChainVO.getEncryptMode(), resultData.getEncryptMode());  
        assertEquals(mockBlockChainVO.getProofType(), resultData.getProofType());  
        assertEquals(mockBlockChainVO.getFileName(), resultData.getFileName());  
        assertEquals(mockBlockChainVO.getChannelId(), resultData.getChannelId());  
        assertEquals(mockBlockChainVO.getIpfsPath(), resultData.getIpfsPath());  
        assertEquals(mockBlockChainVO.getFromAddr(), resultData.getFromAddr());  
  
        // 验证Mock方法被正确调用  
        verify(blockChainService, times(1)).getBlockChainDetails(txHash, id);  
    }  
  
    @Test  
    void getBlockChainDetailsWithInvalidParams() {  
        // 准备测试数据  
        String invalidTxHash = "";  
        Long id = 1L;  
  
        // 配置Mock行为 - 当传入无效参数时抛出异常  
        when(blockChainService.getBlockChainDetails(invalidTxHash, id))  
            .thenThrow(new RuntimeException("Invalid transaction hash"));  
  
        // 执行测试并验证异常  
        RuntimeException exception = assertThrows(RuntimeException.class, () -> {  
            controller.getBlockChainDetails(invalidTxHash, id);  
        });  
  
        assertEquals("Invalid transaction hash", exception.getMessage());  
  
        // 验证Mock方法被正确调用  
        verify(blockChainService, times(1)).getBlockChainDetails(invalidTxHash, id);  
    }  
  
    @Test  
    void getBlockChainDetailsWithNullId() {  
        // 准备测试数据  
        String txHash = "test_tx_hash";  
        Long id = null;  
  
        // 配置Mock行为 - 当传入null id时抛出异常  
        when(blockChainService.getBlockChainDetails(txHash, id))  
            .thenThrow(new RuntimeException("配件ID不能为空"));  
  
        // 执行测试并验证异常  
        RuntimeException exception = assertThrows(RuntimeException.class, () -> {  
            controller.getBlockChainDetails(txHash, id);  
        });  
  
        assertEquals("配件ID不能为空", exception.getMessage());  
  
        // 验证Mock方法被正确调用  
        verify(blockChainService, times(1)).getBlockChainDetails(txHash, id);  
    }  
  
    @Test  
    void getBlockChainDetailsWithNullTxHash() {  
        // 准备测试数据  
        String txHash = null;  
        Long id = 1L;  
  
        // 配置Mock行为 - 当传入null txHash时抛出异常  
        when(blockChainService.getBlockChainDetails(txHash, id))  
            .thenThrow(new RuntimeException("交易哈希值不能为空"));  
  
        // 执行测试并验证异常  
        RuntimeException exception = assertThrows(RuntimeException.class, () -> {  
            controller.getBlockChainDetails(txHash, id);  
        });  
  
        assertEquals("交易哈希值不能为空", exception.getMessage());  
  
        // 验证Mock方法被正确调用  
        verify(blockChainService, times(1)).getBlockChainDetails(txHash, id);  
    }  
}
```

```
@ExtendWith(MockitoExtension.class)  
class TbVehicleAccessoryControllerTest {  
  
    @Mock  
    private IBlockChainService blockChainService;  
  
    @InjectMocks  
    private TbVehicleAccessoryController controller;  
      
    private MockMvc mockMvc;  
    private ObjectMapper objectMapper;  
  
    @BeforeEach  
    void setUp() {  
        MockitoAnnotations.openMocks(this);  
        // 初始化MockMvc  
        mockMvc = MockMvcBuilders.standaloneSetup(controller).build();  
        // 初始化ObjectMapper用于JSON处理  
        objectMapper = new ObjectMapper();  
    }  
  
    @Test  
    void getBlockChainDetails() throws Exception {  
        // 准备测试数据  
        String txHash = "test_tx_hash_123456";  
        Long id = 1L;  
        BlockChainVO mockBlockChainVO = new BlockChainVO();  
        mockBlockChainVO.setTxHash(txHash);  
        mockBlockChainVO.setBlockHeight("1000");  
        mockBlockChainVO.setBlockHash("block_hash_abc123");  
        mockBlockChainVO.setBizId("biz_id_001");  
        mockBlockChainVO.setSigner("测试签名方");  
        mockBlockChainVO.setTxTime("2023-01-01 12:00:00");  
        mockBlockChainVO.setAccessoryType("钣金件");  
        mockBlockChainVO.setDescription("测试描述");  
        mockBlockChainVO.setSignature("test_signature");  
        mockBlockChainVO.setPublicKey("test_public_key");  
        mockBlockChainVO.setEncryptMode(1L);  
        mockBlockChainVO.setProofType(2L);  
        mockBlockChainVO.setFileName("test_file.txt");  
        mockBlockChainVO.setChannelId("channel_1");  
        mockBlockChainVO.setIpfsPath("ipfs_path");  
        mockBlockChainVO.setFromAddr("from_address");  
  
        // 配置Mock行为  
        when(blockChainService.getBlockChainDetails(txHash, id)).thenReturn(mockBlockChainVO);  
  
        // 使用MockMvc执行HTTP GET请求并验证结果  
        mockMvc.perform(get("/lvguan/accessory/getBlockChainDetails")  
                .param("txHash", txHash)  
                .param("id", id.toString())  
                .contentType(MediaType.APPLICATION_JSON))  
                .andExpect(status().isOk())  
                .andExpect(content().contentType(MediaType.APPLICATION_JSON))  
                .andExpect(jsonPath("$.code").value(200))  
                .andExpect(jsonPath("$.msg").value("操作成功"))  
                .andExpect(jsonPath("$.data.txHash").value(txHash))  
                .andExpect(jsonPath("$.data.blockHeight").value("1000"))  
                .andExpect(jsonPath("$.data.blockHash").value("block_hash_abc123"))  
                .andExpect(jsonPath("$.data.bizId").value("biz_id_001"))  
                .andExpect(jsonPath("$.data.signer").value("测试签名方"));  
  
        // 验证Mock方法被正确调用  
        verify(blockChainService, times(1)).getBlockChainDetails(txHash, id);  
    }  
  
}
```

写测试遇到的问题

1. 网上大多数例子都是在 service 层使用 Junit+Mockito 编写单元测试，都会使用when().thenReturn() 来模拟对象被调用。但这种写法不会调用真实逻辑
   
2. 涉及区块链上传，就只能用 mock 了吧？要是直接调用真实的逻辑代码会污染区块链的数据
3. 我学习了在测试类中使用事务的方式，即添加@Transactional注解确保测试后数据回滚，这样来测试新增确实很方便了使用事务在执行完毕后回滚，
4. 
5. 也不是那么方便高度依赖数据库，因为需要一些写好的数据来验证结果


```
//import com.ruoyi.lvguan.controller.vo.dashboard.TitleVO;  
//import com.ruoyi.lvguan.domain.TbInsurancePolicy;  
//import com.ruoyi.lvguan.mapper.TbInsurancePolicyMapper;  
//import com.ruoyi.lvguan.mapper.TbVehicleAccessoryOrderMapper;  
//import com.ruoyi.lvguan.repository.TbVehicleAccessoryRepository;  
//import org.junit.jupiter.api.BeforeEach;  
//import org.junit.jupiter.api.Test;  
//import org.mockito.InjectMocks;  
//import org.mockito.Mock;  
//import org.mockito.MockitoAnnotations;  
//  
//import java.util.Arrays;  
//import java.util.List;  
//  
//import static org.junit.jupiter.api.Assertions.assertEquals;  
//import static org.junit.jupiter.api.Assertions.assertNotNull;  
//import static org.mockito.Mockito.*;  
//  
//class DashboardServiceImplTest {  
//  
//    @Mock  
//    private TbInsurancePolicyMapper policyMapper;  
//  
//    @Mock  
//    private TbVehicleAccessoryOrderMapper accessoryOrderMapper;  
//  
//    @Mock  
//    private TbVehicleAccessoryRepository accessoryRepository;  
//  
//    @InjectMocks  
//    private DashboardServiceImpl dashboardService;  
//  
//    @BeforeEach  
//    void setUp() {  
//        MockitoAnnotations.openMocks(this);  
//    }  
//  
//    @Test  
//    void getTopData_shouldReturnCorrectTitleVOList() {  
//        // Given  
//        when(policyMapper.getTotalNumber()).thenReturn(100);  
//        when(policyMapper.getNumberByDate()).thenReturn(10);  
//        when(accessoryOrderMapper.getTotalNumber()).thenReturn(50);  
//        when(accessoryRepository.count()).thenReturn(200L);  
//  
//        TbInsurancePolicy policy1 = new TbInsurancePolicy();  
//        policy1.setPolicyPremium("8500");  
//        policy1.setInsurancePolicyCode("POLICY001");  
//  
//        TbInsurancePolicy policy2 = new TbInsurancePolicy();  
//        policy2.setPolicyPremium("17000");  
//        policy2.setInsurancePolicyCode("POLICY002");  
//  
//        when(policyMapper.getALl()).thenReturn(Arrays.asList(policy1, policy2));  
//  
//        // When  
//        List<TitleVO> result = dashboardService.getTopData();  
//  
//        // Then  
//        assertNotNull(result);  
//        assertEquals(5, result.size());  
//  
//        // 验证各项数据  
//        TitleVO policyTotalTitle = result.get(0);  
//        assertEquals("保单总数", policyTotalTitle.getDisplayName());  
//        assertEquals("100", policyTotalTitle.getValue());  
//  
//        TitleVO newPolicyCountTitle = result.get(1);  
//        assertEquals("新增保单数", newPolicyCountTitle.getDisplayName());  
//        assertEquals("10", newPolicyCountTitle.getValue());  
//  
//        TitleVO premiumReductionTitle = result.get(2);  
//        assertEquals("保费下降总额", premiumReductionTitle.getDisplayName());  
//        // 计算过程:  
//        // policy1: 原保费 = 8500/0.85 = 10000, 下降 = 10000-8500 = 1500//        // policy2: 原保费 = 17000/0.85 = 20000, 下降 = 20000-17000 = 3000//        // 总下降 = 1500+3000 = 4500, 转为万元单位 = 4500/10000 = 0.45//        assertEquals("0.45", premiumReductionTitle.getValue());  
//  
//        TitleVO claimTotalTitle = result.get(3);  
//        assertEquals("出险总数", claimTotalTitle.getDisplayName());  
//        assertEquals("50", claimTotalTitle.getValue());  
//  
//        TitleVO lowCarbonSupplyTotalTitle = result.get(4);  
//        assertEquals("低碳件供货总数", lowCarbonSupplyTotalTitle.getDisplayName());  
//        assertEquals("200", lowCarbonSupplyTotalTitle.getValue());  
//  
//        // 验证方法调用  
//        verify(policyMapper, times(1)).getTotalNumber();  
//        verify(policyMapper, times(1)).getNumberByDate();  
//        verify(policyMapper, times(1)).getALl();  
//        verify(accessoryOrderMapper, times(1)).getTotalNumber();  
//        verify(accessoryRepository, times(1)).count();  
//    }  
//  
//    @Test  
//    void calculatePremiumReductionAmount_withValidPolicies_shouldCalculateCorrectAmount() {  
//        // 注意：由于calculatePremiumReductionAmount是私有方法，我们通过公共方法getTopData来间接测试它  
//  
//        // Given  
//        when(policyMapper.getTotalNumber()).thenReturn(0);  
//        when(policyMapper.getNumberByDate()).thenReturn(0);  
//        when(accessoryOrderMapper.getTotalNumber()).thenReturn(0);  
//        when(accessoryRepository.count()).thenReturn(0L);  
//  
//        TbInsurancePolicy policy1 = new TbInsurancePolicy();  
//        policy1.setPolicyPremium("8500");  
//        policy1.setInsurancePolicyCode("POLICY001");  
//  
//        TbInsurancePolicy policy2 = new TbInsurancePolicy();  
//        policy2.setPolicyPremium("17000");  
//        policy2.setInsurancePolicyCode("POLICY002");  
//  
//        when(policyMapper.getALl()).thenReturn(Arrays.asList(policy1, policy2));  
//  
//        // When  
//        List<TitleVO> result = dashboardService.getTopData();  
//  
//        // Then  
//        TitleVO premiumReductionTitle = result.get(2);  
//        assertEquals("保费下降总额", premiumReductionTitle.getDisplayName());  
//        assertEquals("0.45", premiumReductionTitle.getValue()); // (1500+3000)/10000 = 0.45万  
//    }  
//  
//    @Test  
//    void calculatePremiumReductionAmount_withEmptyPolicyList_shouldReturnZero() {  
//        // Given  
//        when(policyMapper.getTotalNumber()).thenReturn(0);  
//        when(policyMapper.getNumberByDate()).thenReturn(0);  
//        when(accessoryOrderMapper.getTotalNumber()).thenReturn(0);  
//        when(accessoryRepository.count()).thenReturn(0L);  
//        when(policyMapper.getALl()).thenReturn(Arrays.asList());  
//  
//        // When  
//        List<TitleVO> result = dashboardService.getTopData();  
//  
//        // Then  
//        TitleVO premiumReductionTitle = result.get(2);  
//        assertEquals("保费下降总额", premiumReductionTitle.getDisplayName());  
//        assertEquals("0.00", premiumReductionTitle.getValue());  
//    }  
//  
//    @Test  
//    void calculatePremiumReductionAmount_withNullPremium_shouldBeHandled() {  
//        // Given  
//        when(policyMapper.getTotalNumber()).thenReturn(0);  
//        when(policyMapper.getNumberByDate()).thenReturn(0);  
//        when(accessoryOrderMapper.getTotalNumber()).thenReturn(0);  
//        when(accessoryRepository.count()).thenReturn(0L);  
//  
//        TbInsurancePolicy policy1 = new TbInsurancePolicy();  
//        policy1.setPolicyPremium(null); // null保费  
//        policy1.setInsurancePolicyCode("POLICY001");  
//  
//        TbInsurancePolicy policy2 = new TbInsurancePolicy();  
//        policy2.setPolicyPremium("17000");  
//        policy2.setInsurancePolicyCode("POLICY002");  
//  
//        when(policyMapper.getALl()).thenReturn(Arrays.asList(policy1, policy2));  
//  
//        // When  
//        List<TitleVO> result = dashboardService.getTopData();  
//  
//        // Then  
//        TitleVO premiumReductionTitle = result.get(2);  
//        assertEquals("保费下降总额", premiumReductionTitle.getDisplayName());  
//        // 只计算policy2的下降金额: (20000-17000)/10000 = 0.30万  
//        assertEquals("0.30", premiumReductionTitle.getValue());  
//    }  
//  
//    @Test  
//    void calculatePremiumReductionAmount_withEmptyPremiumString_shouldBeHandled() {  
//        // Given  
//        when(policyMapper.getTotalNumber()).thenReturn(0);  
//        when(policyMapper.getNumberByDate()).thenReturn(0);  
//        when(accessoryOrderMapper.getTotalNumber()).thenReturn(0);  
//        when(accessoryRepository.count()).thenReturn(0L);  
//  
//        TbInsurancePolicy policy1 = new TbInsurancePolicy();  
//        policy1.setPolicyPremium(""); // 空字符串保费  
//        policy1.setInsurancePolicyCode("POLICY001");  
//  
//        TbInsurancePolicy policy2 = new TbInsurancePolicy();  
//        policy2.setPolicyPremium("17000");  
//        policy2.setInsurancePolicyCode("POLICY002");  
//  
//        when(policyMapper.getALl()).thenReturn(Arrays.asList(policy1, policy2));  
//  
//        // When  
//        List<TitleVO> result = dashboardService.getTopData();  
//  
//        // Then  
//        TitleVO premiumReductionTitle = result.get(2);  
//        assertEquals("保费下降总额", premiumReductionTitle.getDisplayName());  
//        // 只计算policy2的下降金额: (20000-17000)/10000 = 0.30万  
//        assertEquals("0.30", premiumReductionTitle.getValue());  
//    }  
//  
//    @Test  
//    void calculatePremiumReductionAmount_withInvalidPremiumFormat_shouldLogWarningAndContinue() {  
//        // Given  
//        when(policyMapper.getTotalNumber()).thenReturn(0);  
//        when(policyMapper.getNumberByDate()).thenReturn(0);  
//        when(accessoryOrderMapper.getTotalNumber()).thenReturn(0);  
//        when(accessoryRepository.count()).thenReturn(0L);  
//  
//        TbInsurancePolicy policy1 = new TbInsurancePolicy();  
//        policy1.setPolicyPremium("invalid"); // 无效格式保费  
//        policy1.setInsurancePolicyCode("POLICY001");  
//  
//        TbInsurancePolicy policy2 = new TbInsurancePolicy();  
//        policy2.setPolicyPremium("17000");  
//        policy2.setInsurancePolicyCode("POLICY002");  
//  
//        when(policyMapper.getALl()).thenReturn(Arrays.asList(policy1, policy2));  
//  
//        // When  
//        List<TitleVO> result = dashboardService.getTopData();  
//  
//        // Then  
//        TitleVO premiumReductionTitle = result.get(2);  
//        assertEquals("保费下降总额", premiumReductionTitle.getDisplayName());  
//        // 只计算policy2的下降金额: (20000-17000)/10000 = 0.30万  
//        assertEquals("0.30", premiumReductionTitle.getValue());  
//    }  
//}
```
