# 项目关键点总结

本项目是基于若依(RuoYi)框架的Spring Boot后台管理系统。以下是需要掌握的关键技术点和模式。

---

## 1. LambdaQueryWrapper 查询条件构造 ⭐⭐⭐

**说明**: 使用MyBatis-Plus的LambdaQueryWrapper进行类型安全的查询条件构造，这是项目中最常用的查询方式。

**典型用法**:
```java
LambdaQueryWrapper<TbInsurancePreorder> queryWrapper = new LambdaQueryWrapper<>();
queryWrapper.like(preorderCode != null, TbInsurancePreorder::getPreOrderCode, preorderCode)
        .eq(status != null, TbInsurancePreorder::getStatus, status)
        .orderByDesc(TbInsurancePreorder::getCreateTime);
Page<TbInsurancePreorder> pageResult = tbInsurancePreorderMapper.selectPage(page, queryWrapper);
```

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/TbInsurancePreorderServiceImpl.java:101-106`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/TbInsuranceRepairServiceImpl.java:141-148`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/TbInsurancePolicyServiceImpl.java:599-612`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/TbVehicleAccessoryServiceImpl.java:73-110`

---

## 2. Elasticsearch 搜索查询 ⭐⭐⭐

**说明**: 项目使用Elasticsearch进行全文搜索，通过BoolQueryBuilder构造复杂查询条件。

**典型用法**:
```java
BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
boolQueryBuilder.must(QueryBuilders.multiMatchQuery(keyWord, fields));
boolQueryBuilder.must(QueryBuilders.termQuery("orderStatus", status));
NativeSearchQuery build = nativeSearchQuery.withQuery(boolQueryBuilder).build();
SearchHits<TbInsurancePolicy> search = elasticsearchRestTemplate.search(build, TbInsurancePolicy.class);
```

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/GlobalSearchServiceImpl.java:127-156`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/TbInsurancePolicyServiceImpl.java:146-189`

**核心服务**: `IGlobalSearchService` 提供统一的Elasticsearch查询封装

---

## 3. 权限控制 (@PreAuthorize) ⭐⭐⭐

**说明**: 使用Spring Security的@PreAuthorize注解进行方法级权限控制，配合自定义的PermissionService。

**典型用法**:
```java
@PreAuthorize("@ss.hasPermi('lvguan:policy:query')")
@GetMapping("/list")
public TableDataInfo list(...) { ... }
```

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/TbInsurancePolicyController.java:72`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/TbInsurancePreorderController.java:35`
- `ruoyi-framework/src/main/java/com/ruoyi/framework/web/service/PermissionService.java:27-40`

**权限服务**: `PermissionService` (bean名称: "ss") 提供权限验证方法

---

## 4. 分页处理 ⭐⭐

**说明**: 使用PageHelper进行分页，在Controller中调用startPage()，然后通过getDataTable()返回分页结果。

**典型用法**:
```java
// Controller中
startPage();
List<InsurancePolicyVO> list = tbInsurancePolicyService.selectPolicyList(insuranceResearchDTO);
Long totalHits = SearchContext.getTotalHits();
SearchContext.clear();
return getDataTable(list, totalHits);

// Service中使用MyBatis-Plus分页
Page<TbInsurancePreorder> page = new Page<>(globalSearchService.getPageable().getPageNumber(), 
                                             globalSearchService.getPageable().getPageSize());
```

**代码位置**:
- `ruoyi-common/src/main/java/com/ruoyi/common/utils/PageUtils.java:18-26`
- `ruoyi-common/src/main/java/com/ruoyi/common/core/controller/BaseController.java:50-52, 76-94`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/TbInsurancePolicyController.java:93-101`

---

## 5. VO/DTO 对象转换 ⭐⭐

**说明**: 使用VO(视图对象)和DTO(数据传输对象)进行数据封装和转换，避免直接暴露实体类。

**典型模式**:
- Controller层接收DTO，返回VO
- Service层进行Entity与VO/DTO之间的转换
- 使用静态工厂方法或转换方法进行对象转换

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/dto/` - DTO定义
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/vo/` - VO定义
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/vo/accessory/AccessoryVO.java:201-225` - 静态转换方法示例

---

## 6. 事务处理 (@Transactional) ⭐⭐

**说明**: 在Service层的增删改方法上使用@Transactional注解保证数据一致性。

**典型用法**:
```java
@Transactional
@Override
public int insert${ClassName}(${ClassName} ${className}) { ... }
```

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/TbInsurancePreorderServiceImpl.java:22`
- `ruoyi-generator/src/main/resources/vm/java/serviceImpl.java.vm:65` - 代码生成模板

---

## 7. Excel导入导出 ⭐⭐

**说明**: 使用ExcelUtil工具类进行Excel的导入导出，配合@Excel注解定义导出字段。

**典型用法**:
```java
// 导出
ExcelUtil<TbInsurancePolicyVo> util = new ExcelUtil<>(TbInsurancePolicyVo.class);
util.exportExcel(response, list, "保单");

// 导入
ExcelUtil<InsurancePolicyImportVo> util = new ExcelUtil<>(InsurancePolicyImportVo.class);
List<InsurancePolicyImportVo> list = util.importExcel(file.getInputStream(), 1);
```

**代码位置**:
- `ruoyi-common/src/main/java/com/ruoyi/common/utils/poi/ExcelUtil.java`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/TbInsurancePolicyController.java:237-238`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/TbInsurancePolicyServiceImpl.java:644-682`

---

## 8. 文件上传下载 ⭐⭐

**说明**: 使用FileUploadUtils进行文件上传，通过MultipartFile接收文件。

**典型用法**:
```java
@PostMapping("/upload")
public AjaxResult uploadFile(@RequestParam("file") MultipartFile file) {
    String filePath = RuoYiConfig.getUploadPath();
    String fileName = FileUploadUtils.upload(filePath, file);
    return AjaxResult.success(fileName);
}
```

**代码位置**:
- `ruoyi-common/src/main/java/com/ruoyi/common/utils/file/FileUploadUtils.java:159-176`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/TbInsurancePolicyController.java:172-188`
- `ruoyi-admin/src/main/java/com/ruoyi/web/controller/common/CommonController.java:75-96`

---

## 9. 部门权限过滤 ⭐⭐⭐

**说明**: 项目特有的业务逻辑，根据用户所属部门(保司/供应商)自动过滤数据。

**核心方法**:
- `deptService.verifyProviderIdAndDeptId(BoolQueryBuilder)` - ES查询过滤
- `deptService.verifyCompanyOrOther(LambdaQueryWrapper)` - MyBatis查询过滤

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/DeptServiceImpl.java:29-88`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/TbInsurancePolicyServiceImpl.java:163, 599`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/GlobalSearchServiceImpl.java:130`

**业务规则**:
- 保司用户: 只能查看本保司的保单 (tenantId过滤)
- 供应商用户: 只能查看本供应商的订单 (providerId过滤)

---

## 10. ServiceImpl 继承模式 ⭐⭐⭐

**说明**: Service实现类继承MyBatis-Plus的ServiceImpl，获得基础的CRUD能力。

**典型模式**:
```java
@Service
public class TbInsurancePolicyServiceImpl extends ServiceImpl<TbInsurancePolicyMapper, TbInsurancePolicy> 
    implements ITbInsurancePolicyService {
    
    @Autowired
    private TbInsurancePolicyMapper tbInsurancePolicyMapper; // 仍需要注入用于自定义方法
}
```

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/TbInsurancePolicyServiceImpl.java:70`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/DeptServiceImpl.java:23`
- 所有 `*ServiceImpl.java` 文件都遵循此模式

---

## 11. 统一响应格式 ⭐⭐

**说明**: 使用 R<T>或 AjaxResult 作为统一响应格式。

**响应类型**:
- `R<T>`: 泛型响应，用于返回具体数据类型
- `AjaxResult`: Map 类型的响应，灵活性更高
- `TableDataInfo`: 分页响应格式

**典型用法**:
```java
return R.ok (data);                    // 成功返回数据
return R.fail ("错误信息");             // 失败返回
Return getDataTable (list, total);     // 分页返回
```

**代码位置**:
- `ruoyi-common/src/main/java/com/ruoyi/common/core/domain/R.java`
- `ruoyi-common/src/main/java/com/ruoyi/common/core/domain/AjaxResult. Java`
- `ruoyi-common/src/main/java/com/ruoyi/common/core/controller/BaseController. Java: 76-158`

---

## 12. 操作日志记录 (@Log) ⭐

**说明**: 使用@Log 注解记录操作日志，通过 AOP 自动记录到数据库。

**典型用法**:
```java
@Log (title = "导入保单", businessType = BusinessType. IMPORT)
@PostMapping ("/import")
public R<Boolean> importInsurance (...) { ... }
```

**代码位置**:
- `ruoyi-common/src/main/java/com/ruoyi/common/annotation/Log. Java`
- `ruoyi-framework/src/main/java/com/ruoyi/framework/aspectj/LogAspect. Java`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/TbInsurancePolicyController. Java: 200, 233`

---

## 13. Controller 继承 BaseController ⭐⭐⭐

**说明**: 所有 Controller 都继承 BaseController，获得通用方法支持。

**提供的方法**:
- `startPage ()` - 设置分页
- `getDataTable ()` - 返回分页数据
- `success ()/error ()` - 返回响应
- `getUserId ()/getDeptId ()/getUsername ()` - 获取当前用户信息

**代码位置**:
- `ruoyi-common/src/main/java/com/ruoyi/common/core/controller/BaseController. Java`
- 所有 Controller 类都继承此类

---

## 14. MyBatis Plus 配置和使用 ⭐⭐

**说明**: 项目同时使用 MyBatis 和 MyBatis-Plus，通过配置支持两者共存。

**关键配置**:
- 逻辑删除: `logic-delete-value: 1, logic-not-delete-value: 0`
- 自动填充: createTime, updateTime 等字段自动填充
- 驼峰转换: `mapUnderscoreToCamelCase: true`

**代码位置**:
- `ruoyi-admin/src/main/resources/application. Yml: 172-179`
- `ruoyi-framework/src/main/java/com/ruoyi/framework/config/MyBatisPlusConfig. Java: 153-171`

---

## 15. SearchContext 线程上下文 ⭐

**说明**: 用于在 Service 层存储查询总数，在 Controller 层获取。主要用于 ES 查询返回总数。

**典型用法**:
```java
// Service 层
SearchContext. SetTotalHits (search. GetTotalHits ());

// Controller 层
Long totalHits = SearchContext. GetTotalHits ();
SearchContext. Clear ();
Return getDataTable (list, totalHits);
```

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/utls/SearchContext. Java`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/GlobalSearchServiceImpl. Java:120`
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/TbInsurancePolicyController. Java: 96-101`

---

## 16. Swagger API 文档 ⭐

**说明**: 使用 Swagger 3 进行 API 文档生成，通过注解描述接口。

**典型用法**:
```java
@Api ("保单管理")
@RestController
@RequestMapping ("/lvguan/policy")
Public class TbInsurancePolicyController {
    
    @ApiOperation ("查询保险单列表")
    @ApiImplicitParams ({
        @ApiImplicitParam (name = "keyword", value = "关键词", ...)
    })
    @GetMapping ("/list")
    Public TableDataInfo list (...) { ... }
}
```

**代码位置**:
- 所有 Controller 类都使用 Swagger 注解
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/TbInsurancePolicyController. Java: 47-83`

---

## 17. SecurityUtils 安全工具类 ⭐⭐

**说明**: 提供获取当前登录用户信息的方法。

**常用方法**:
- `SecurityUtils. GetLoginUser ()` - 获取登录用户
- `SecurityUtils. GetDeptId ()` - 获取部门 ID
- `SecurityUtils. GetUserId ()` - 获取用户 ID
- `SecurityUtils. GetUsername ()` - 获取用户名

**代码位置**:
- `ruoyi-common/src/main/java/com/ruoyi/common/utils/SecurityUtils. Java`
- 项目中大量使用，用于权限判断和数据过滤

---

## 18. Redis 缓存 ⭐⭐⭐

**说明**: 项目使用 Redis 进行缓存，主要用于 Token 存储、字典缓存、系统配置缓存、在线用户管理和接口限流。

**核心工具类**: `RedisCache` - 封装了 Redis 的常用操作

**主要使用场景**:

1. **Token 存储** - 用户登录信息存储在 Redis 中
```java
// TokenService 中使用
RedisCache.SetCacheObject (userKey, loginUser, expireTime, TimeUnit. MINUTES);
LoginUser user = redisCache.GetCacheObject (userKey);
```

2. **字典缓存** - 系统字典数据缓存
```java
// DictUtils 中使用
RedisCache.SetCacheObject (getCacheKey (key), dictDatas);
List<SysDictData> dictDatas = getDictCache (key);
```

3. **接口限流** - 使用 Redis + Lua 脚本实现
```java
// RateLimiterAspect 中使用
@RateLimiter (key = "test", count = 10, time = 60)
Long number = redisTemplate.Execute (limitScript, keys, count, time);
```

4. **在线用户管理** - 存储和管理在线用户信息

**代码位置**:
- `ruoyi-common/src/main/java/com/ruoyi/common/core/redis/RedisCache. Java` - Redis 工具类
- `ruoyi-framework/src/main/java/com/ruoyi/framework/config/RedisConfig. Java` - Redis 配置
- `ruoyi-framework/src/main/java/com/ruoyi/framework/web/service/TokenService. Java: 54-154` - Token 存储
- `ruoyi-common/src/main/java/com/ruoyi/common/utils/DictUtils. Java: 29-48` - 字典缓存
- `ruoyi-framework/src/main/java/com/ruoyi/framework/aspectj/RateLimiterAspect. Java: 49-74` - 接口限流

**配置位置**:
- `ruoyi-admin/src/main/resources/application-dev. Yml: 28-49` - Redis 连接配置

**Redis 常用操作**:
- `setCacheObject (key, value, timeout, timeUnit)` - 设置缓存对象
- `getCacheObject (key)` - 获取缓存对象
- `deleteObject (key)` - 删除缓存
- `expire (key, timeout, timeUnit)` - 设置过期时间
- `hasKey (key)` - 判断 key 是否存在

---

## 19. 区块链存证 ⭐⭐

**说明**: 项目集成了区块链存证功能，用于将配件信息上链保存，提供数据不可篡改的保障。主要应用于配件质检数据的区块链存证。

**核心服务**: `IBlockChainService` - 区块链服务接口

**主要功能**:
1. **区块链登录** - 通过 API Key 和 Secret 获取访问 Token
2. **数据上链** - 将配件信息上传到区块链
3. **查询详情** - 根据交易 Hash 查询区块链上的数据详情

**典型用法**:
```java
// 配件数据上链
String txHash = blockChainService.UploadChain (accessory, providerName);

// 查询区块链详情
BlockChainVO details = blockChainService.GetBlockChainDetails (txHash, accessoryId);
```

**业务流程**:
1. 配件质检完成 → 调用区块链服务上传数据
2. 上传成功返回交易 Hash (txHash)
3. 将 txHash 保存到数据库
4. 后续可通过 txHash 查询区块链上的原始数据

**配置**:
```yaml
BlockChain:
  url: https://jnbsjx.inspuriip.com/ibds/api
  ApiKey: NGAKZ 253 VWO 7 EL 4 FQ 9 ID 8 T 1 CSY 6 JBXUP
  ApiSecret: XWMH 8 UEFDZ 6 RJ 94 Q 0 N 532 GSOVIL 1 BYPCTA 7 K
```

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/IBlockChainService. Java` - 服务接口
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/service/impl/BlockChainServiceImpl. Java` - 服务实现
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/vo/blockchain/BlockChainVO. Java` - 区块链 VO
- `ruoyi-admin/src/main/resources/application. Yml: 166-169` - 配置文件

**关键参数**:
- `bizId`: 业务 ID，使用配件对象的 hashCode
- `bizType`: 业务类型，2 表示公共存证服务
- `encryptMode`: 加密方式，1 表示授权加密
- `data`: 需要上链的数据，配件信息序列化后的字符串
- `tx_hash`: 交易 Hash，上链成功后返回，用于后续查询

**注意事项**:
- 每次上传前需要先调用`loginBlockChain ()`获取 Token
- 上传超时时间设置为 20 秒
- 上传失败会抛出 RuntimeException

---

## 20. 全局异常处理 ⭐⭐⭐

**说明**: 使用@RestControllerAdvice 统一处理所有异常，避免异常直接暴露给前端，提供友好的错误提示。

**核心类**: `GlobalExceptionHandler` - 全局异常处理器

**处理的异常类型**:
- `ServiceException` - 业务异常
- `AccessDeniedException` - 权限校验异常
- `MethodArgumentNotValidException` - 参数校验异常
- `BindException` - 数据绑定异常
- `RuntimeException` - 运行时异常
- `Exception` - 系统异常

**典型用法**:
```java
// Service 层抛出业务异常
Throw new ServiceException ("操作失败: " + reason);

// Controller 层使用@Validated 自动触发参数校验
@PostMapping ("/add")
public R<InsurancePolicyVO> add (@RequestBody @Validated InsurancePolicyDTO dto) { ... }
```

**代码位置**:
- `ruoyi-framework/src/main/java/com/ruoyi/framework/web/exception/GlobalExceptionHandler. Java`
- `ruoyi-common/src/main/java/com/ruoyi/common/exception/ServiceException. Java`

**关键特性**:
- 统一返回格式: 所有异常都通过 AjaxResult 返回
- 异常日志记录: 自动记录异常到日志文件
- 友好错误提示: 根据异常类型返回合适的错误信息

---

## 21. 数据校验 (@Valid/@Validated) ⭐⭐

**说明**: 在 Controller 层使用 JSR-303 数据校验注解进行参数验证，配合全局异常处理器自动处理校验失败。

**常用注解**:
- `@NotNull` - 不能为空
- `@NotBlank` - 字符串不能为空白
- `@Valid` / `@Validated` - 启用校验
- `@Xss` - 防止 XSS 攻击

**典型用法**:
```java
@PostMapping ("/add")
public R<InsurancePolicyVO> add (@RequestBody @Validated InsurancePolicyDTO dto) {
    // 校验失败会自动抛出 MethodArgumentNotValidException
    // 由 GlobalExceptionHandler 统一处理
}
```

**DTO 中使用**:
```java
Public class InsurancePolicyDTO {
    @NotNull (message = "保单号不可为空")
    Private String insurancePolicyCode;
    
    @NotBlank (message = "车牌号不可为空")
    Private String licensePlateNumber;
}
```

**代码位置**:
- `ruoyi-platform/src/main/java/com/ruoyi/lvguan/controller/dto/` - 所有 DTO 都使用校验注解
- `ruoyi-framework/src/main/java/com/ruoyi/framework/web/exception/GlobalExceptionHandler. Java: 129-135` - 校验异常处理

---

## 22. JWT Token 认证机制 ⭐⭐⭐

**说明**: 使用 JWT (JSON Web Token) 进行无状态身份认证，Token 存储在 Redis 中，实现了 Token 自动刷新机制。

**认证流程**:
1. 用户登录 → 生成 UUID 作为 Token 标识
2. LoginUser 存入 Redis (key: login_tokens:{uuid})
3. JWT Token 包含 uuid 和 username
4. 请求时解析 JWT → 从 Redis 获取 LoginUser
5. Token 剩余不足 20 分钟自动刷新

**核心组件**:
- `TokenService` - Token 服务，负责生成、解析、刷新 Token
- `JwtAuthenticationTokenFilter` - JWT 过滤器，拦截请求验证 Token

**典型用法**:
```java
// 创建 Token
String token = tokenService.CreateToken (loginUser);

// 获取用户信息
LoginUser loginUser = tokenService.GetLoginUser (request);

// 刷新 Token (自动调用)
TokenService.VerifyToken (loginUser);
```

**代码位置**:
- `ruoyi-framework/src/main/java/com/ruoyi/framework/web/service/TokenService. Java`
- `ruoyi-framework/src/main/java/com/ruoyi/framework/security/filter/JwtAuthenticationTokenFilter. Java`
- `ruoyi-framework/src/main/java/com/ruoyi/framework/config/SecurityConfig. Java:126` - JWT 过滤器配置

**关键特性**:
- 无状态认证: 不需要 Session，适合分布式部署
- 自动刷新: Token 剩余不足 20 分钟自动延长有效期
- 双重存储: JWT 携带基本信息，详细用户信息存 Redis

---

## 23. 异步处理 (AsyncManager) ⭐⭐

**说明**: 使用异步管理器处理耗时操作，避免阻塞主线程，主要用于操作日志和登录日志的异步记录。

**核心组件**:
- `AsyncManager` - 异步任务管理器 (单例模式)
- `AsyncFactory` - 异步任务工厂，创建具体任务
- `ThreadPoolConfig` - 线程池配置

**使用场景**:
- 操作日志记录 - 避免日志记录影响业务性能
- 登录日志记录 - 异步记录登录信息
- 其他耗时操作 - 不需要立即返回结果的任务

**典型用法**:
```java
// 异步记录操作日志
AsyncManager.Me (). Execute (AsyncFactory.RecordOper (operLog));

// 异步记录登录日志
AsyncManager.Me (). Execute (AsyncFactory.RecordLogininfor (username, status, message));
```

**代码位置**:
- `ruoyi-framework/src/main/java/com/ruoyi/framework/manager/AsyncManager. Java`
- `ruoyi-framework/src/main/java/com/ruoyi/framework/manager/factory/AsyncFactory. Java`
- `ruoyi-framework/src/main/java/com/ruoyi/framework/aspectj/LogAspect. Java:125` - 异步记录日志

---

## 24. 定时任务 (Quartz) ⭐

**说明**: 项目集成了 Quartz 定时任务框架，支持动态任务管理，可通过管理界面配置任务。

**功能特性**:
- 支持 Cron 表达式配置
- 支持任务暂停/恢复
- 支持任务执行日志记录
- 支持并发控制

**代码位置**:
- `ruoyi-quartz/src/main/java/com/ruoyi/quartz/` - 定时任务模块
- `ruoyi-quartz/src/main/java/com/ruoyi/quartz/util/AbstractQuartzJob. Java` - 抽象任务类
- `ruoyi-quartz/src/main/java/com/ruoyi/quartz/controller/SysJobController. Java` - 任务管理接口

**注意**: 当前配置中的 ScheduleConfig 已被注释，如需启用需要在配置文件中开启

---

## 25. 多数据源支持 ⭐

**说明**: 项目支持多数据源动态切换，通过@DataSource 注解指定使用的数据源。

**使用方式**:
```java
@DataSource (DataSourceType. SLAVE)
public List<User> selectUserList () {
    // 使用从库查询
}

@DataSource (DataSourceType. MASTER)
Public void insertUser (User user) {
    // 使用主库插入
}
```

**实现原理**:
- `DynamicDataSource` - 动态数据源路由
- `DynamicDataSourceContextHolder` - ThreadLocal 存储当前数据源
- `DataSourceAspect` - AOP 切面自动切换数据源

**代码位置**:
- `ruoyi-framework/src/main/java/com/ruoyi/framework/datasource/DynamicDataSource. Java`
- `ruoyi-framework/src/main/java/com/ruoyi/framework/aspectj/DataSourceAspect. Java`
- `ruoyi-common/src/main/java/com/ruoyi/common/annotation/DataSource. Java`

**配置位置**:
- `ruoyi-admin/src/main/resources/application-dev. Yml: 21-27` - 从库配置 (默认关闭)

---

## 26. 数据字典系统 ⭐⭐

**说明**: 系统提供完整的数据字典功能，字典数据缓存在 Redis 中，通过 DictUtils 工具类访问。

**核心工具类**: `DictUtils` - 字典工具类

**常用方法**:
```java
// 根据字典类型和值获取标签
String label = DictUtils.GetDictLabel ("sys_user_sex", "1"); // 返回: "男"

// 根据字典类型和标签获取值
String value = DictUtils.GetDictValue ("sys_user_sex", "男"); // 返回: "1"

// 获取字典缓存
List<SysDictData> dictDatas = DictUtils.GetDictCache ("sys_user_sex");
```

**使用场景**:
- 状态枚举值转换 (如: 0→正常, 1→停用)
- 类型选项显示 (如: 保单类型、配件品质)
- 下拉框数据源

**代码位置**:
- `ruoyi-common/src/main/java/com/ruoyi/common/utils/DictUtils. Java`
- `ruoyi-system/src/main/java/com/ruoyi/system/service/impl/SysDictDataServiceImpl. Java`

**字典管理**:
- 通过系统管理界面配置字典类型和字典数据
- 字典数据变更后自动清除 Redis 缓存

---

## 总结

以上 26 个关键点是理解和使用本项目的基础。掌握这些模式后，可以快速理解项目的代码结构，避免重复查看相似代码。

**优先级说明**:
- ⭐⭐⭐ 必须掌握，代码中大量使用
- ⭐⭐ 重要，经常使用
- ⭐ 了解即可，特定场景使用

**特别提醒**:
- **Redis**: 若依框架的核心基础设施，Token、缓存、限流等都需要 Redis 支持
- **区块链**: 项目特色功能，配件数据上链存证，提供数据不可篡改保障

